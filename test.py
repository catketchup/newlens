import sys
from sympy import Symbol
import numpy as np
from sympy.physics.wigner import wigner_3j
import matplotlib.pyplot as plt
import cwignerd
import camb

# test call a c module in python, used f2py to transfered a c routine into a python module(.c to .pyf to .so)


class Call_Wignerd:
    def __init__(self, s1, s2, npoints):
        self.s1 = s1
        self.s2 = s2
        self.npoints = npoints
        self.zvec, self.wvec = cwignerd.init_gauss_legendre_quadrature(npoints)

    def array(self):
        return np.linspace(0, 1, 100)

    def cf_from_cl(self):

        lmax = len(self.array())-1
        return cwignerd.wignerd_cf_from_cl(self.s1, self.s2, 1, self.npoints, lmax, self.zvec, self.array())


test = Call_Wignerd(0, 1, 100)
plt.plot(test.zvec, test.cf_from_cl())
# plt.show()

# take a class as an argument in a function


class call:
    def __init__(self, s1, s2):
        self.s1 = s1
        self.s2 = s2

    def add(self):
        return self.s1+self.s2


def Func(call_1):  # attention, the name of the argument is not important, as long as the class put in later has the function called in this function
    print(call_1.add())


new = call(1, 1)

Func(new)

# test sphinx-doc


def add(a, b):
    """this is a test of docstring generated by sphinx-doc 

    :param a: ist no 
    :param b: 2nd no
    :returns: sum of a and b
    :rtype: int

    """
    return a + b

# test emulating numeric type


class Num:
    def __init__(self, math):
        self.math = math

    def __str__(self):
        return str(self.math)
    ## 对象出现在 + 号的左边

    def __add__(self, other):
        return self.math + other

    ## 对象出现在 + 号的右边
    def __radd__(self, other):
        return self.math + other
    # +=运算时自动触发，若没有用add

    def __iadd__(self, other):
        return Num(self.math + other)


n = Num(12)

m = n+10
print(n)
print(m)

# test __str__


class Temp:
    def __init__(self, math):
        self.math = math

    def __str__(self):
        return str(self.math)


x = Temp(1)
print(x)


# test emulating logic types


class Logic:
    def __init__(self, a):
        self.a = a
        # 大于

    def __gt__(self, other):
        return self.a > other
    # 小于

    def __lt__(self, other):
        return self.a < other
    # 等于 ，  == 会触发，不实现__ne__,!=也会触发该方法

    def __eq__(self, other):
        return self.a == other
    # 大于等于

    def __ge__(self, other):
        return self.a >= other
    # 小于等于

    def __le__(self, other):
        return self.a <= other
    # 不等于：  ！=

    def __ne__(self, other):
        return self.a != other


L = Logic(10)
print(L > 10)
print(L != 10)
print(L == 10)

# test manipulation of np.array
flt = np.zeros(5)
cltt = [1, 2, 3, 4, 5]
cltt = np.array(cltt)
print(flt)
print(cltt[2:])
print(1./cltt[2:])

# test comment box, mark the words you want to comment and choose comment box

###############
# comment box #
###############


# test import camb
camb.__file__


# test lambda function
def fun(x):
    return lambda a: a+x


x = fun(10)
x(2)
